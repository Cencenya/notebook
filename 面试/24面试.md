### 国美旗下 

##### 1、讲一下对闭包、原型链的理解

闭包是指在一个函数内部定义的函数可以访问该函数的内部变量和作用域，即使在外部函数执行完毕后也可以继续访问。在JavaScript中，由于函数是一等公民，函数可以作为返回值或参数传递给其他函数，这就为闭包的应用提供了可能性。

##### 2、讲一下事件委托、react 合成事件

**事件委托**（Event Delegation）: 是一种常见的**前端优化技术**，它利用事件冒泡的特性，将**事件处理程序添加到父元素上**，从而减少对子元素的事件绑定，提高性能和代码简洁度。

当一个事件在 DOM 树上触发时，它会沿着元素的祖先元素一直向上传播，直到达到根节点。利用这一特性，可以把事件处理程序添加到祖先元素上，然后通过判断事件的 `target` 属性来识别实际触发事件的子元素，从而执行相应操作。

 **React 中，合成事件（Synthetic Event）**是 React 提供的一种**跨浏览器兼容的事件系统**。

React 通过事件委托来管理所有事件，统一绑定到顶层容器上，然后根据实际触发事件的元素来调用相应的事件处理函数。这样可以减少内存消耗和提高性能。

React 为开发者提供了一整套合成事件，包括鼠标事件、键盘事件、表单事件等，使用方式与原生事件类似。通过这些合成事件，开发者可以更方便地处理用户交互，并且不必担心跨浏览器的兼容性问题。

**核心原理：**

React 的合成事件系统是 React 提供的一套跨浏览器兼容的事件处理机制，它的核心原理包括以下几点：

1. **事件委托**：React 使用事件委托的方式来管理所有事件。所有事件都被绑定到顶层容器上，而不是直接绑定到每个具体的 DOM 元素上。这样可以减少事件处理程序的数量，提高性能。7
2. **事件池**：React 使用事件池来重用事件对象，避免频繁创建和销毁事件对象带来的性能开销。当事件被触发时，React 会从事件池中获取一个事件对象，并在事件处理完成后将其归还给事件池。
3. **合成事件对象**：React 封装了原生事件对象，提供了统一的跨浏览器接口。合成事件对象包含了与原生事件对象相似的属性和方法，但也有一些额外的特性，比如可以通过 `stopPropagation` 和 `preventDefault` 来控制事件传播和默认行为。
4. **事件处理优化**：React 对事件处理进行了优化，采用批量更新和合并更新的方式来减少不必要的渲染。在事件处理过程中，React 会将多个状态更新合并为一个更新，然后再统一执行更新操作，减少渲染次数，提高性能。

总的来说，React 合成事件系统的核心原理是利用事件委托、事件池、合成事件对象和事件处理优化来统一管理和处理事件，提高性能、简化代码编写，并保证跨浏览器的兼容性。这些特性使得 React 在处理用户交互时更加高效和可靠。

##### 3、css 如果更改公共组件的样式



深度选择器

##### 4、css 画一个三角形

```css
// 上三角
.triangle {
  width: 0;
  height: 0;
  border-left: 50px solid transparent;
  border-right: 50px solid transparent;
  border-bottom: 100px solid red;
}
```

##### 5、讲一下对 react 类组件和函数组件的理解

- **语法**：类组件使用 ES6 class 语法，而函数组件是普通的 JavaScript 函数。
- **状态管理**：类组件使用 this.state 和 this.setState 进行状态管理，而函数组件使用 useState Hook 来添加状态。
- **生命周期**：类组件有完整的生命周期方法（如 componentDidMount、componentDidUpdate 等），而函数组件使用 useEffect Hook 来模拟生命周期行为。

总的来说，随着 React Hooks 的引入，函数组件已经成为编写大多数 React 组件的首选方式，因为它们更简洁、易于理解，并且可以使用 Hooks 提供的功能。但类组件仍然是 React 中的一部分，并且在某些情况下仍然很有用。

6、组件通信的方式
7、为什么不能直接更改 state

未有后续消息

### 杭州七凌科技-网易七鱼前端 通过

1/10 3:30pm 电话面试

##### 一面

##### 1、常用的 es6 语法有哪些

1. **let 和 const**：`let` 和 `const` 替代了传统的 `var` 关键字，用于声明变量。`let` 声明的变量具有块级作用域，而 `const` 声明的变量是常量，不可重新赋值。

2. **箭头函数**：箭头函数是一种更简洁的函数声明语法，可以减少代码量并改变 `this` 的指向。

   ```js
   javascriptCopy Code// 传统函数
   function add(a, b) {
     return a + b;
   }
   
   // 箭头函数
   const add = (a, b) => a + b;
   ```

3. **模板字符串**：使用反引号（`）来创建多行字符串和嵌入表达式。

   ```js
   javascriptCopy Codeconst name = 'Alice';
   const greeting = `Hello, ${name}!`;
   ```

4. **解构赋值**：可以轻松地从数组或对象中提取值并赋给变量。

   ```js
   javascriptCopy Code// 数组解构赋值
   const [x, y] = [1, 2];
   
   // 对象解构赋值
   const { firstName, lastName } = { firstName: 'John', lastName: 'Doe' };
   ```

5. **默认参数**：在函数参数中可以设置默认值。

   ```js
   javascriptCopy Codefunction greet(name = 'World') {
     console.log(`Hello, ${name}!`);
   }
   ```

6. **展开运算符**：用三个点（...）来展开数组或对象。

   ```js
   javascriptCopy Code// 展开数组
   const arr1 = [1, 2, 3];
   const arr2 = [...arr1, 4, 5];
   
   // 展开对象
   const obj1 = { foo: 'bar' };
   const obj2 = { ...obj1, baz: 'qux' };
   ```

7. **类和继承**：ES6 引入了类（class）语法糖来创建对象和实现继承。

   ```js
   javascriptCopy Codeclass Animal {
     constructor(name) {
       this.name = name;
     }
   
     speak() {
       console.log(`${this.name} makes a noise.`);
     }
   }
   
   class Dog extends Animal {
     speak() {
       console.log(`${this.name} barks.`);
     }
   }
   ```

2、箭头函数有用过吗、箭头函数和普通函数的区别是什么？
3、var、let、const 有什么区别、它们的作用域分别是什么？
4、什么是事件循环？
5、script 标签的 async defer 的区别？
6、css 实现水平垂直居中实现方式有多少？
7、react 中常用的 hook 有哪些
8、有自定义 hooks 吗？在什么业务场景下使用？
9、什么情况下需要自己封装 hooks？
10、使用过 react 的哪些状态库？分别适合在什么场景下使用？
11、ts 的基础类型有哪些？js 没有的数据类型 ts 有的数据类型是哪些？
12、说一下浏览器的同源策略
13、有哪些方式可以实现跨域？
14、做过哪些有挑战性的项目、解决过哪些复杂的功能？在该项目中承担什么样的角色？
15、indexDB 存储的是什么数据、为什么要用 indexDB 存储数据？什么时候需要存储到后端？

##### 16、useEffect和useLayouteffect的区别？

**useEffect**

1. **异步执行**：`useEffect` 中的副作用代码是异步执行的，不会阻塞浏览器渲染。
2. **延迟执行**：`useEffect` 中的副作用代码会在浏览器完成绘制之后才执行，因此可能会导致页面先渲染显示，然后再更新。
3. **适用性**：适合大多数副作用操作，比如数据获取、订阅事件、DOM 操作等。

```
jsxCopy CodeuseEffect(() => {
  // 副作用代码
}, [dependency]);
```

**useLayoutEffect**

1. **同步执行**：`useLayoutEffect` 中的副作用代码是同步执行的，会在 DOM 更新之前执行。
2. **立即执行**：`useLayoutEffect` 中的副作用代码会在浏览器进行布局（layout）和绘制（painting）之前执行，可以在更新前立即处理。
3. **适用性**：适合需要在更新之前立即执行的副作用操作，比如 DOM 计算、样式计算等。

```
jsxCopy CodeuseLayoutEffect(() => {
  // 副作用代码
}, [dependency]);
```

### 总结

- 如果副作用代码不需要阻塞浏览器渲染，并且不需要立即执行，则可以使用 `useEffect`。
- 如果副作用代码需要在 DOM 更新之前立即执行，或者需要进行 DOM 计算和样式计算，可以考虑使用 `useLayoutEffect`。

##### 二面

1、研究过 react 的源码吗？
2、react 如何实现并发渲染？
3、react 调和到一半的 fiber 树，此时有一个高优先级的任务，react 从中断位置调和还是清除掉调和到一半 fiber，重新重头开始调和？
4、为什么会重头开始调和？
5、如何从中断位置开始调和？时间切片怎么运行？
6、ts 高级类型使用过哪些？
7、ReturnType 怎么实现？
8、说一下 extends infer？
9、业务哪些方面技术
10、使用响应式的库遇到过哪些问题，他的优缺点有哪些？
11、mobx 如何实现的？
12、了解 proxy 吗？如何实现响应式数据？
13、webpack 了解多少？
14、ahooks 使用过哪些？自己实现过吗？

##### 三面

跳槽频繁 跳槽 gap 超过三个月

### 软通-滴滴出行 未过

1/10 7:30pm 腾讯会议

1、介绍业务、担任角色？
2、详细介绍一下异常操作怎么处理
3、登录持久化
4、怎么做性能优化
5、弱网下怎么操作
6、对大模型的理解
7、如何封装可视化编辑组件、如何解决遇到的问题？
8、怎么思考组件的通用性、可拓展性？
9、vue 了解过吗、与 react 的相同点和不同点？
10、简单介绍一下 promise 的原理、构造函数是同步还是异步？
11、webpack 打包用过吗？
12、对 bable 的理解
13、前端异常分析怎么做？html 原生怎么做？script 标签怎么做？
14、项目上线的异常监控怎么做？
15、介绍一下浏览器的缓存机制

### 班牛

1/12 10:00am 线下
缺乏 vue 经验

### 科锐-字节

1/12 3:00pm 飞书（带笔试）

```js
// 补充callApiWithTimeout 如果超时ms getSomethingByApi未返回数据 就reject
function getSomethingByApi {
  return axios.get('xxx')
}

function callApiWithTimeout(ms = 1000): Promise<any> {
}

function callApiWithTimeout(ms = 1000): Promise<any> {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      reject(false)
    }, ms)
    getSomethingByApi.then((res, error) => resolve(res)).catch((error) => reject(error))
  })
}

```



```js

// 查找树的深度
const obj = {
  a: 1
}
// 1
const obj1 = {
  a: 1,
  b: {
    b1: {
      b2: 10
    }
  }
}
// 3
function maxDepth(obj) {
}

// 方案一
function maxDepth(obj) {
  let Depth = 1;
  for (const key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      const element = obj[key];
      if (typeof (element) == 'object') {
        const height = search(element, 2)
        if (height > Depth) Depth = height
      }
    }
  }
  console.log(Depth)
  return Depth;
}

function search(obj, height) {
  let depth = height;
  Object.keys(obj).forEach((item) => {
    if (typeof (obj[item]) == 'object') {
      depth = search(obj[item], depth + 1);
    }
  })
  return depth
}
// 优化 方案一 
function maxLength(obj) {
  let depth = 1;
  for (const key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      const element = obj[key];
      if (typeof element === 'object'&& maxLength(element) + 1 >depth) {
        depth = maxLength(element) + 1
      }

    }
  }
  return depth
}

function maxDepth(obj){
  let depth = 1;
  if(typeof obj !== 'object') return -1;

}

//方案二 关键点 如何缓存记录当前递归的深度 
function findDepth(obj, isFirst): number {
  if (typeof obj !== 'object' && isFirst) {
    return -1;
  }
  return Object.keys(obj).reduce((max, key) => {
    if (typeof (obj[key]) == 'object' && obj[key] !== null) {
      const depth = findDepth(obj[key], false);
      if (depth > max) {
        return depth
      }
    }
    return max
  }, 1)

}
```







```js
// 1. 请实现一个函数，将下面树状结构的 json 对象中所有的 icon 属性删除，要求在不改变原来 json 值的前提下返回新的对应 json 对象（请注意该树状 json 深度未知）
[
  {
    "id": "huuEQ5Pv",
    "parentId": "0",
    "name": "菜单1",
    "subMenus": [
      {
        "id": "R1PRWTsS",
        "parentId": "huuEQ5Pv",
        "name": "菜单2",
        "route": "/s1",
        "type": "menu",
        "icon": "123",
        "subMenus": [
          ...
              ]
      },
      {
        "id": "R2PRWTsxx",
        "parentId": "huuEQ5Pv",
        "name": "菜单3",
        "route": "/s2",
        "type": "menu",
        "icon": ""
      },
      ...
      ]
  }
]；
      
      function delIcon(Arr) {

}

function delIcon(Arr) {
  const newJson = [];
  Arr.forEach(item => {
    const NewItem = {
      ...item
    }
    if (Reflect.has(NewItem, 'icon')) {
      delete NewItem.icon
    }
    if (item.subMenus && item.subMenus.length > 0) {
      const newSubMenus = search(item.subMenus)
      NewItem.subMenus = newSubMenus
    }
    newJson.push(NewItem)

  });
  return newJson;
}

function search(Arr) {
  return Arr.map((item) => {
    const NewItem = {
      ...item
    }
    if (Reflect.has(NewItem, 'icon')) {
      delete NewItem.icon
    }
    if (item.subMenus && item.subMenus.length > 0) {
      const newSubMenus = search(item.subMenus)
      NewItem.subMenus = newSubMenus
    }
    return NewItem

  })
}
```





```js
// 1. 请用Promise实现函数，要求每 5 秒获取一个随机数，如果该随机数小于 5，则函数立即结束，如果大于5，则 60 秒后函数运行结束


function Main() {
 return new Promise((resolve, reject) => {
    let radomNumber = 0
    let timer = setInterval(() => {
      radomNumber = Math.random() * 10;
      if (radomNumber > 5) {
        clearInterval(timer);
        setTimeout(() => {
          resolve(radomNumber)
        }, 60 * 1000)
      }
    }, 5000)
  })
}
```




```js
// 1. 实现一个持久化 function 的自定义 Hook： useMemoizedFn，解决 Hook 中的 dep 引起的闭包问题，同时保证函数调用的准确性与实时性，使用方式如下：

function useMemoizedFn(fn) {
  const fnRef = useRef(fn);
  fnRef.current = useMemo(() => fn, [fn]);
  const memoizedFn = useRef();
  if (!memoizedFn.current) {
    memoizedFn.current = function (...args) {
      return fnRef.current.apply(this, args)
    }
  }
  return memoizedFn.current

}


function useMemoizedFn(fn) {
  const fnRef = useRef();

  // 使用useCallback将函数包裹起来，并将fn作为依赖项
  const memoizedFn = useCallback(
    (...args) => {
      // 在每次函数调用时，更新fnRef的值为最新的fn
      fnRef.current = fn;
      // 调用最新的fn
      return fnRef.current(...args);
    },
    [fn]
  );

  return memoizedFn;
}
```



```js
const testData = [
  {
    id: '7067179125001158661',
  },
  {
    id: '7067448596362166278',
    children: [
      {
        id: '7067486541085442053',
        children: [
          {
            id: '7067486541085474821',
            children: [
              {
                id: '7067878618105495558',
              },
            ],
          },
          {
            id: '7067825150707679238',
          },
        ],
      },
    ],
  },
  {
    id: '7067179088024174597',
    children: [
      {
        id: '7068143816268054533',
        children: [
          {
            id: '7068143740090597381',
            children: [
              {
                id: '7068143740090630149',
              },
            ],
          },
        ],
      },
    ],
  },
  {
    id: '7067179173667831814',
  },
];

// 返回一个扁平的数组
// ['7067179125001158661', '7067448596362166278', '7067486541085442053', '7067486541085474821', '7067878618105495558', '7067825150707679238', '7067179088024174597', '7068143816268054533', '7068143740090597381', '7068143740090630149', '7067179173667831814']
// function getDataIds(data) {
//   // todo
//   return [xxx];
// }


const res = getDataIds(testData);
console.log(res);

function getDataIds(data) {
  const ids = [];
  function traverse(items) {
    if (items) ids.push(items.id);
    if (items.children) {
      items.children.forEach(child => {
        traverse(child);
      });
    }
  }
  data.forEach(item => {
    traverse(item);
  });
  return ids;
}


1、学习前端的途径有哪些?
2、http位于五层网络模型的哪一层?五层模型包含哪些?各层主要负责什么?
3、讲一下tcp的三次握手，如何保证传输的可靠性、拥塞控制和如何处理超时重传?
4、tcp和udp的区别?
5、http如果基于udp可行吗?如何实现?
6、讲一下dns协议?如何进行做到域名和IP地址的映射?基于传输层的什么协议实现?
7、htpps解决的是什么问题?ss|进行加密在报文中有体现吗、是哪一部分?服务端加密使用的公钥还是私钥?数字对称加密和非对称加密有什么区别?
8、前端模块化有哪些方案?common]s和esm的区别?如何进行转换?
9、position的属性有哪些?具体说明一下
10、antd的弹出层组件被其他组件遮挡住，如何解决?getcontainer是如何实现?可以通过样式解决这个问题为什么还要提供这个方法呢?11、说-下xss，csp
12、0.1+0.2 是否等于0.3?为什么?为什么会存在精度丢失?如何表示754标准的浮点数?怎么解决精度丢失问题?
13、递归笔试题
```


