### 国美旗下 

##### 1、讲一下对闭包、原型链的理解
闭包是指在一个函数内部定义的函数可以访问该函数的内部变量和作用域，即使在外部函数执行完毕后也可以继续访问。在JavaScript中，由于函数是一等公民，函数可以作为返回值或参数传递给其他函数，这就为闭包的应用提供了可能性。


2、讲一下事件委托、react 合成事件

3、css 如果更改公共组件的样式
深度选择器
4、css 画一个三角形
5、讲一下对 react 类组件和函数组件的理解
6、组件通信的方式
7、为什么不能直接更改 state

未有后续消息

### 杭州七凌科技-网易七鱼前端 通过

1/10 3:30pm 电话面试

##### 一面

1、常用的 es6 语法有哪些
2、箭头函数有用过吗、箭头函数和普通函数的区别是什么？
3、var、let、const 有什么区别、它们的作用域分别是什么？
4、什么是事件循环？
5、script 标签的 async defer 的区别？
6、css 实现水平垂直居中实现方式有多少？
7、react 中常用的 hook 有哪些
8、有自定义 hooks 吗？在什么业务场景下使用？
9、什么情况下需要自己封装 hooks？
10、使用过 react 的哪些状态库？分别适合在什么场景下使用？
11、ts 的基础类型有哪些？js 没有的数据类型 ts 有的数据类型是哪些？
12、说一下浏览器的同源策略
13、有哪些方式可以实现跨域？
14、做过哪些有挑战性的项目、解决过哪些复杂的功能？在该项目中承担什么样的角色？
15、indexDB 存储的是什么数据、为什么要用 indexDB 存储数据？什么时候需要存储到后端？

##### 二面

1、研究过 react 的源码吗？
2、react 如何实现并发渲染？
3、react 调和到一半的 fiber 树，此时有一个高优先级的任务，react 从中断位置调和还是清除掉调和到一半 fiber，重新重头开始调和？
4、为什么会重头开始调和？
5、如何从中断位置开始调和？时间切片怎么运行？
6、ts 高级类型使用过哪些？
7、ReturnType 怎么实现？
8、说一下 extends infer？
9、业务哪些方面技术
10、使用响应式的库遇到过哪些问题，他的优缺点有哪些？
11、mobx 如何实现的？
12、了解 proxy 吗？如何实现响应式数据？
13、webpack 了解多少？
14、ahooks 使用过哪些？自己实现过吗？

##### 三面

跳槽频繁 跳槽 gap 超过三个月

### 软通-滴滴出行 未过

1/10 7:30pm 腾讯会议

1、介绍业务、担任角色？
2、详细介绍一下异常操作怎么处理
3、登录持久化
4、怎么做性能优化
5、弱网下怎么操作
6、对大模型的理解
7、如何封装可视化编辑组件、如何解决遇到的问题？
8、怎么思考组件的通用性、可拓展性？
9、vue 了解过吗、与 react 的相同点和不同点？
10、简单介绍一下 promise 的原理、构造函数是同步还是异步？
11、webpack 打包用过吗？
12、对 bable 的理解
13、前端异常分析怎么做？html 原生怎么做？script 标签怎么做？
14、项目上线的异常监控怎么做？
15、介绍一下浏览器的缓存机制

### 班牛

1/12 10:00am 线下
缺乏 vue 经验

### 科锐-字节

1/12 3:00pm 飞书（带笔试）

```js
// 补充callApiWithTimeout 如果超时ms getSomethingByApi未返回数据 就reject
function getSomethingByApi {
  return axios.get('xxx')
}

function callApiWithTimeout(ms = 1000): Promise<any> {
}

function callApiWithTimeout(ms = 1000): Promise<any> {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      reject(false)
    }, ms)
    getSomethingByApi.then((res, error) => resolve(res)).catch((error) => reject(error))
  })
}

```



```js

// 查找树的深度
const obj = {
  a: 1
}
// 1
const obj1 = {
  a: 1,
  b: {
    b1: {
      b2: 10
    }
  }
}
// 3
function maxDepth(obj) {
}

// 方案一
function maxDepth(obj) {
  let Depth = 1;
  for (const key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      const element = obj[key];
      if (typeof (element) == 'object') {
        const height = search(element, 2)
        if (height > Depth) Depth = height
      }
    }
  }
  console.log(Depth)
  return Depth;
}

function search(obj, height) {
  let depth = height;
  Object.keys(obj).forEach((item) => {
    if (typeof (obj[item]) == 'object') {
      depth = search(obj[item], depth + 1);
    }
  })
  return depth
}
// 优化 方案一 
function maxLength(obj) {
  let depth = 1;
  for (const key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      const element = obj[key];
      if (typeof element === 'object'&& maxLength(element) + 1 >depth) {
        depth = maxLength(element) + 1
      }

    }
  }
  return depth
}

function maxDepth(obj){
  let depth = 1;
  if(typeof obj !== 'object') return -1;

}

//方案二 关键点 如何缓存记录当前递归的深度 
function findDepth(obj, isFirst): number {
  if (typeof obj !== 'object' && isFirst) {
    return -1;
  }
  return Object.keys(obj).reduce((max, key) => {
    if (typeof (obj[key]) == 'object' && obj[key] !== null) {
      const depth = findDepth(obj[key], false);
      if (depth > max) {
        return depth
      }
    }
    return max
  }, 1)

}
```







```js
// 1. 请实现一个函数，将下面树状结构的 json 对象中所有的 icon 属性删除，要求在不改变原来 json 值的前提下返回新的对应 json 对象（请注意该树状 json 深度未知）
[
  {
    "id": "huuEQ5Pv",
    "parentId": "0",
    "name": "菜单1",
    "subMenus": [
      {
        "id": "R1PRWTsS",
        "parentId": "huuEQ5Pv",
        "name": "菜单2",
        "route": "/s1",
        "type": "menu",
        "icon": "123",
        "subMenus": [
          ...
              ]
      },
      {
        "id": "R2PRWTsxx",
        "parentId": "huuEQ5Pv",
        "name": "菜单3",
        "route": "/s2",
        "type": "menu",
        "icon": ""
      },
      ...
      ]
  }
]；
      
      function delIcon(Arr) {

}

function delIcon(Arr) {
  const newJson = [];
  Arr.forEach(item => {
    const NewItem = {
      ...item
    }
    if (Reflect.has(NewItem, 'icon')) {
      delete NewItem.icon
    }
    if (item.subMenus && item.subMenus.length > 0) {
      const newSubMenus = search(item.subMenus)
      NewItem.subMenus = newSubMenus
    }
    newJson.push(NewItem)

  });
  return newJson;
}

function search(Arr) {
  return Arr.map((item) => {
    const NewItem = {
      ...item
    }
    if (Reflect.has(NewItem, 'icon')) {
      delete NewItem.icon
    }
    if (item.subMenus && item.subMenus.length > 0) {
      const newSubMenus = search(item.subMenus)
      NewItem.subMenus = newSubMenus
    }
    return NewItem

  })
}
```





```js
// 1. 请用Promise实现函数，要求每 5 秒获取一个随机数，如果该随机数小于 5，则函数立即结束，如果大于5，则 60 秒后函数运行结束


function Main() {
 return new Promise((resolve, reject) => {
    let radomNumber = 0
    let timer = setInterval(() => {
      radomNumber = Math.random() * 10;
      if (radomNumber > 5) {
        clearInterval(timer);
        setTimeout(() => {
          resolve(radomNumber)
        }, 60 * 1000)
      }
    }, 5000)
  })
}
```




```js
// 1. 实现一个持久化 function 的自定义 Hook： useMemoizedFn，解决 Hook 中的 dep 引起的闭包问题，同时保证函数调用的准确性与实时性，使用方式如下：

function useMemoizedFn(fn) {
  const fnRef = useRef(fn);
  fnRef.current = useMemo(() => fn, [fn]);
  const memoizedFn = useRef();
  if (!memoizedFn.current) {
    memoizedFn.current = function (...args) {
      return fnRef.current.apply(this, args)
    }
  }
  return memoizedFn.current

}


function useMemoizedFn(fn) {
  const fnRef = useRef();

  // 使用useCallback将函数包裹起来，并将fn作为依赖项
  const memoizedFn = useCallback(
    (...args) => {
      // 在每次函数调用时，更新fnRef的值为最新的fn
      fnRef.current = fn;
      // 调用最新的fn
      return fnRef.current(...args);
    },
    [fn]
  );

  return memoizedFn;
}
```



```js
const testData = [
  {
    id: '7067179125001158661',
  },
  {
    id: '7067448596362166278',
    children: [
      {
        id: '7067486541085442053',
        children: [
          {
            id: '7067486541085474821',
            children: [
              {
                id: '7067878618105495558',
              },
            ],
          },
          {
            id: '7067825150707679238',
          },
        ],
      },
    ],
  },
  {
    id: '7067179088024174597',
    children: [
      {
        id: '7068143816268054533',
        children: [
          {
            id: '7068143740090597381',
            children: [
              {
                id: '7068143740090630149',
              },
            ],
          },
        ],
      },
    ],
  },
  {
    id: '7067179173667831814',
  },
];

// 返回一个扁平的数组
// ['7067179125001158661', '7067448596362166278', '7067486541085442053', '7067486541085474821', '7067878618105495558', '7067825150707679238', '7067179088024174597', '7068143816268054533', '7068143740090597381', '7068143740090630149', '7067179173667831814']
// function getDataIds(data) {
//   // todo
//   return [xxx];
// }


const res = getDataIds(testData);
console.log(res);

function getDataIds(data) {
  const ids = [];
  function traverse(items) {
    if (items) ids.push(items.id);
    if (items.children) {
      items.children.forEach(child => {
        traverse(child);
      });
    }
  }
  data.forEach(item => {
    traverse(item);
  });
  return ids;
}


1、学习前端的途径有哪些?
2、http位于五层网络模型的哪一层?五层模型包含哪些?各层主要负责什么?
3、讲一下tcp的三次握手，如何保证传输的可靠性、拥塞控制和如何处理超时重传?
4、tcp和udp的区别?
5、http如果基于udp可行吗?如何实现?
6、讲一下dns协议?如何进行做到域名和IP地址的映射?基于传输层的什么协议实现?
7、htpps解决的是什么问题?ss|进行加密在报文中有体现吗、是哪一部分?服务端加密使用的公钥还是私钥?数字对称加密和非对称加密有什么区别?
8、前端模块化有哪些方案?common]s和esm的区别?如何进行转换?
9、position的属性有哪些?具体说明一下
10、antd的弹出层组件被其他组件遮挡住，如何解决?getcontainer是如何实现?可以通过样式解决这个问题为什么还要提供这个方法呢?11、说-下xss，csp
12、0.1+0.2 是否等于0.3?为什么?为什么会存在精度丢失?如何表示754标准的浮点数?怎么解决精度丢失问题?
13、递归笔试题
```


