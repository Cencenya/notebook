# html

### script 标签的 async defer 的区别？

GUI渲染线程在解析html文档时，如果遇到script标签会下载里面的内容，从而阻塞文档的解析
async defer 都可以避免阻塞文档解析，当遇到script标签带这种标识时，会将下载任务交给网络请求线程，从而继续解析文档。
但是下载完成之后，async会停止解析文档，转而去执行script内的内容。defer会等到整个文档解析完成再去执行script内的内容

# css

### 说一下position有哪些类型以及各个类型的特点？
static（静态定位）：这是默认的定位方式，元素按照正常的文档流进行排列，不受top、bottom、left、right等属性的影响。

relative（相对定位）：元素相对于其正常位置进行定位，通过设置top、bottom、left、right等属性来调整元素的位置。相对定位不会使元素脱离文档流，其他元素的布局不会受到影响。

absolute（绝对定位）：元素相对于其最近的已定位祖先元素进行定位，如果没有已定位的祖先元素，则相对于文档的初始坐标进行定位。通过设置top、bottom、left、right等属性来精确控制元素的位置。绝对定位会使元素脱离正常的文档流，其他元素的布局可能会受到影响。

fixed（固定定位）：元素相对于浏览器窗口进行定位，即使页面滚动，元素也会保持固定的位置。通过设置top、bottom、left、right等属性来确定元素在视口中的位置。固定定位会使元素脱离正常的文档流，其他元素的布局可能会受到影响。

sticky（粘性定位）：元素根据用户的滚动位置进行定位。粘性定位会将元素固定在距离顶部、底部、左侧或右侧一定距离的位置，直到达到指定的偏移值才会取消固定定位。粘性定位在支持的浏览器上表现类似于相对定位和固定定位的结合。

### 更改公共组件样式
```css
:global{

}
深度选择器
```
### css画一个三角形

```css
// 上三角
.triangle {
  width: 0;
  height: 0;
  border-left: 50px solid transparent;
  border-right: 50px solid transparent;
  border-bottom: 100px solid red;
}
```

### css 实现水平垂直居中实现方式有多少？
```css
.container {
  display: flex;
  justify-content: center; /* 水平居中 */
  align-items: center; /* 垂直居中 */
}
// 子元素使用绝对定位，并且通过 top: 50%; 和 left: 50%; 将子元素的左上角定位在父容器的中心，然后通过 transform: translate(-50%, -50%); 将子元素向左上方移动自身宽度和高度的一半，实现了水平和垂直居中。
.container {
  position: relative;
}

.child {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
}
```

# js

### 说一下es6的新特性以及对他们的理解
变量声明 let const 
结构赋值 拓展运算符
Array Object String新增方法 
Symbol原始数据类型 对象的属性名只能为string类型 Symbol代表独一无二的 拓展了对象的属性名
set、map和proxy数据结构
Reflect 、Promise、Generator、async、await、class
模块化 module import 
装饰器语法

### var let const的区别

let声明的是变量，const声明的是常量，并且声明就必须赋值
从执行上下文的变量存放位置来看 
var声明的变量存放在变量环境`VariableEnvironment`,let、const声明的变量存放此法环境`LexicalEnvironment`
var 存在变量提升 这是由于js引擎解释器会优先将var和function声明（函数提升）提到作用域的顶部 
let、const 不存在变量提升（暂时性死区），具有块级作用域

### 箭头函数和普通函数的区别

* 声明方式：箭头函数使用const+ => 普通函数使用function
* 箭头函数不可以使用 arguments 对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。
* 箭头函数不可以使用 yield 命令，因此箭头函数不能用作 Generator 函数。
* this bind： 
箭头函数的this由外层的作用域决定，不是由调用方式决定，也就意味着内部的this始终指向外层的this，它会从自己的作用域链的上一层继承 this（因此无法使用 apply / call / bind 进行绑定 this 值）
普通函数的this由调用方式决定，在全局上下文中，this指向window，如果在对象的方法中，this指向调用方法的对象。
```js
class Dog {
  name;
  constructor() {
    nc.on('event', function() {
      console.log(this);
    });
    nc.on('event', () => {
      console.log(this)
    });
  }
}
```
* 构造函数：
由于this指向不同，在构造函数方面也会存在差异。普通函数可以使用new关键字，箭头函数不能使用new关键字

回顾一下new的过程：

1.创建一个新的空对象:var obj = {}
2.obj的proto属性指向Fn的prototype属性:obj.proto = Fn.prototype（形成原型链:obj.proto -->Fn.prototype --->Object.prototype --->null）
3.绑定this执行和执行构造函数:Fn.call(obj,”jack“)
4.返回新的对象：return obj

所以：
从第二步来看，箭头函数没有 prototype 属性 ，而 new 命令在执行时需要将构造函数的 prototype 赋值给新的对象的 __proto__

从第三步来看，箭头函数没有自己的 this，无法调用 call，apply。

从js引擎的角度分析：
JavaScript函数两个内部方法: [[Call]]和[[Construct]]

直接调用时执行[[Call]]方法, 直接执行函数体

new调用时执行[[Construct]]方法, 创建一个实例对象

箭头函数并没有[[Construct]]方法, 所以不能被用作构造函数

另外, 可以参考Proxy中的handler.construct方法

当使用 new 关键字调用一个函数时，JavaScript 引擎会检查函数是否有 [[Construct]] 方法。如果函数有 [[Construct]] 方法，它会被调用来创建一个新的实例对象；如果函数没有 [[Construct]] 方法，那么将会抛出一个错误。

Construct实现了new的过程？？ 错误
[[Construct]] 视为实现 new 关键字的关键内部方法之一
在new的第三步中，它涉及到调用构造函数本身。这个调用是通过内部的 [[Construct]] 方法实现的。如果构造函数内部具有 [[Construct]] 方法，那么它将被调用来创建对象实例。否则，JavaScript 引擎将采取其他默认的行为来创建对象实例。

### 闭包

闭包的定义：指有权访问另一个函数作用域中的变量的函数，一般情况就是在一个函数中包含另一个函数。

闭包的作用：访问函数内部变量、保持函数在环境中一直存在，不会被垃圾回收机制处理

函数内部声明的变量是局部的，只能在函数内部访问到，但是函数外部的变量是对函数内部可见的。

**定义**：一个闭包是一个可以自己拥有独立的环境与变量的的表达式（通常是函数，因为 ES6 有了块级作用域的概念），是指有权访问另一个函数作用域中的变量的函数。也就是说，闭包让你可以在一个内层函数中访问到其外层函数的作用域。

闭包其实只是一个绑定了**执行环境的函数**

在 JavaScript 中，根据词法作用域的规则，**内部函数总是可以访问其外部函数中声明的变量，当通过调用一个外部函数返回一个内部函数后，即使该外部函数已经执行结束了，但是内部函数引用外部函数的变量依然保存在内存中，我们就把这些变量的集合称为闭包**

1. 可以在函数的外部访问到函数内部的局部变量。
2. 让这些变量始终保存在内存中，不会随着函数的结束而自动销毁。

```javascript
function init() {
  var name = "Mozilla"; // name 是一个被 init 创建的局部变量
  function displayName() {
    // displayName() 是内部函数，一个闭包
    alert(name); // 使用了父函数中声明的变量
  }
  displayName();
}
const closure = init(); // 调用外部函数，得到一个闭包
closure(); // 调用闭包
```
### 原型链

顾名思义，就是通过原型`prototype`来建立关系的链式数据结构。
当访问一个对象的属性或方法时，如果该对象本身没有这个属性或方法，JavaScript 引擎会沿着原型链向上查找，直到找到对应的属性或方法或者到达原型链的顶端。
对象含有_proto_属性，函数含有一个prototype属性。
在new的过程中会做这一步，用于建立原型链，
person.__proto__ == Person.prototype

### 事件循环

由于js是单线程，那么如何管理异步和IO相关操作呢？
js是单线程，但浏览器是多线程，它还包括GUI渲染线程、网络请求线程、定时器线程、事件监听线程、webWork线程
当js主线程遇到其他线程的任务时，会交给其他线程在后台处理，处理完成之后的回调函数放入任务队列中，当js主线程将执行栈中的任务执行完之后，就会取出任务列队中的任务执行。
由于任务的优先级不同，分为宏任务和微任务队列，优先执行微任务队列，再执行宏任务。
宏任务：
- script(整体代码)
- setTimeout()
- setInterval()
- postMessage
- I/O
- UI 交互事件
微任务：
- new Promise().then(回调)
- await
- MutationObserver(html5 新特性)
整个流程被称为事件循环

### 事件委托

**事件委托**（Event Delegation）: 是一种常见的**前端优化技术**，它利用事件冒泡的特性，将**事件处理程序添加到父元素上**，从而减少对子元素的事件绑定，提高性能和代码简洁度。

当一个事件在 DOM 树上触发时，它会沿着元素的祖先元素一直向上传播，直到达到根节点。利用这一特性，可以把事件处理程序添加到祖先元素上，然后通过判断事件的 `target` 属性来识别实际触发事件的子元素，从而执行相应操作。





# React

### useMemo和useCallBack的区别？
useMemo 用于缓存计算结果,返回值为组件或者对象，useCallback 用于缓存回调函数。它们都可以在某些情况下提高组件的性能

### 普通的工具函数和hook的区别？
hook能够让在不使用class的情况下，使用class的一些特性，例如，副作用，状态管理等
工具函数能够在任何场景下使用， hook只能在函数组件内使用，并且遵循hook的使用原则，不能在循环、条件语句或子函数中调用等

### 讲一下useSetState的封装过程
setState的功能 
接受一个对象，指定更新某个特殊的属性state
接受一个函数，函数的返回值更新state
```ts
  const newSetState = useCallback<ReturnSetStateFn<T>>((state, cb) => {
    let newState = state;
    setState((prevState: T) => {
      executeCb.current = cb;
      if (isFunction(state) && typeof state === "function") {
        newState = state(prevState);
      }
      return { ...prevState, ...newState };
    });
  }, []);
  ```
第二个参数接受一个回调函数，在更新完state后执行
```ts
  useEffect(() => {
    const { current: cb } = executeCb;
    if (typeof cb === "function") isFunction(cb) && cb();
  }, [executeCb.current]);

```

### react 类组件和函数组件的区别

- **语法**：类组件使用 ES6 class 语法，而函数组件是普通的 JavaScript 函数。
- **状态管理**：类组件使用 this.state 和 this.setState 进行状态管理，而函数组件使用 useState Hook 来添加状态。
- **生命周期**：类组件有完整的生命周期方法（如 componentDidMount、componentDidUpdate 等），而函数组件使用 useEffect Hook 来模拟生命周期行为。

总的来说，随着 React Hooks 的引入，函数组件已经成为编写大多数 React 组件的首选方式，因为它们更简洁、易于理解，并且可以使用 Hooks 提供的功能。但类组件仍然是 React 中的一部分，并且在某些情况下仍然很有用。
##### useEffect和useLayouteffect的区别？

**useEffect**

1. **异步执行**：`useEffect` 中的副作用代码是异步执行的，不会阻塞浏览器渲染。
2. **延迟执行**：`useEffect` 中的副作用代码会在浏览器完成绘制之后才执行，因此可能会导致页面先渲染显示，然后再更新。
3. **适用性**：适合大多数副作用操作，比如数据获取、订阅事件、DOM 操作等。

```
jsxCopy CodeuseEffect(() => {
  // 副作用代码
}, [dependency]);
```

**useLayoutEffect**

1. **同步执行**：`useLayoutEffect` 中的副作用代码是同步执行的，会在 DOM 更新之前执行。
2. **立即执行**：`useLayoutEffect` 中的副作用代码会在浏览器进行布局（layout）和绘制（painting）之前执行，可以在更新前立即处理。
3. **适用性**：适合需要在更新之前立即执行的副作用操作，比如 DOM 计算、样式计算等。

```
jsxCopy CodeuseLayoutEffect(() => {
  // 副作用代码
}, [dependency]);
```

### react 中常用的 hook 有哪些

状态hook：useState、useReducer
带副作用hook：useEffect、useLayoutEffect、useRef、useCallback、useMemo、useImperativeHandle
所谓“副作用”，是指在组件渲染过程中执行的除了更新组件 UI 以外的操作，比如数据获取、订阅、手动修改 DOM 等。

### 什么情况下需要自己封装 hooks？
共享逻辑、复杂状态逻辑、副作用封装、抽象组件逻辑

### react合成事件

React 通过事件委托来管理所有事件，统一绑定到顶层容器上，然后根据实际触发事件的元素来调用相应的事件处理函数。这样可以减少内存消耗和提高性能。

React 为开发者提供了一整套合成事件，包括鼠标事件、键盘事件、表单事件等，使用方式与原生事件类似。通过这些合成事件，开发者可以更方便地处理用户交互，并且不必担心跨浏览器的兼容性问题。

**核心原理：**

1. **事件委托**：React 使用事件委托的方式来管理所有事件。所有事件都被绑定到顶层容器上，而不是直接绑定到每个具体的 DOM 元素上。这样可以减少事件处理程序的数量，提高性能。7
2. **事件池**：React 使用事件池来重用事件对象，避免频繁创建和销毁事件对象带来的性能开销。当事件被触发时，React 会从事件池中获取一个事件对象，并在事件处理完成后将其归还给事件池。
3. **合成事件对象**：React 封装了原生事件对象，提供了统一的跨浏览器接口。合成事件对象包含了与原生事件对象相似的属性和方法，但也有一些额外的特性，比如可以通过 `stopPropagation` 和 `preventDefault` 来控制事件传播和默认行为。
4. **事件处理优化**：React 对事件处理进行了优化，采用批量更新和合并更新的方式来减少不必要的渲染。在事件处理过程中，React 会将多个状态更新合并为一个更新，然后再统一执行更新操作，减少渲染次数，提高性能。

总的来说，React 合成事件系统的核心原理是利用事件委托、事件池、合成事件对象和事件处理优化来统一管理和处理事件，提高性能、简化代码编写，并保证跨浏览器的兼容性。这些特性使得 React 在处理用户交互时更加高效和可靠。

### react 如何实现并发渲染？
通过一下关键技术实现：
- 任务调度器和优先级管理：
- 任务分割和时间切片
- 并发渲染和中断恢复
- 异步更新和批处理

### react 调和到一半的 fiber 树，此时有一个高优先级的任务，react 从中断位置调和还是清除掉调和到一半 fiber，重新重头开始调和？
根据当前工作特性和已完成的工作量而定
如果当前已调和的任务较多，react倾向于继续当前调和，并不会抛弃已调和好的数据


# typescript

### js和ts的区别？ts带来的好处有哪些？讲一下泛型、在什么业务场景下使用？
类型检查系统 js弱类型 ts强类型
编译 js可直接在浏览器 ndoe下执行 ts需要转换为js才能执行

### ts 的基础类型有哪些？js 没有的数据类型 ts 有的数据类型是哪些？
布尔类型 (boolean)：表示逻辑值，可以是 true 或 false。

数字类型 (number)：表示数字，可以是整数或浮点数，也可以使用二进制、八进制、十进制或十六进制表示。

字符串类型 (string)：表示文本数据，可以使用单引号或双引号包裹字符串。

数组类型 (array)：表示一组相同类型的值的有序集合，可以使用类型 + 方括号的形式声明数组类型，也可以使用泛型 Array<type> 表示数组类型。

元组类型 (tuple)：表示固定长度和固定类型的数组，元组中每个位置的类型是固定的，通常用于表示一个固定长度的数组。

枚举类型 (enum)：表示一组具有命名的常量集合，可以使用关键字 enum 声明。

任意类型 (any)：表示任意类型，可以赋予任何类型的值。

空类型 (void)：表示没有任何类型，通常用于标识函数没有返回值。

Null 和 Undefined：分别表示 null 和 undefined。

Never 类型：表示永远不会有返回值的类型。

对象类型 (object)：表示非原始类型的类型，即除了 number、string、boolean、symbol、null 或 undefined 之外的类型。

Unknown 类型：表示未知类型，类似于 any 类型，但更加安全，因为它不能赋值给其他类型。

联合类型 (Union Types)：表示一个值可以是多种类型中的一种，使用 | 分隔多个类型。

交叉类型 (Intersection Types)：表示将多个类型合并为一个新的类型，使用 & 运算符。

类型别名 (Type Aliases)：用于给一个类型起一个新的名字，可以使用 type 关键字定义类型别名。

字面量类型 (Literal Types)：表示一个具体的值，而不是一个变量，可以通过字面量来定义。

索引类型 (Index Types)：用于描述对象的属性和方法类型，包括字符串索引签名和数字索引签名。

映射类型 (Mapped Types)：通过映射已知的类型来创建新类型。

可选类型 (Optional Types)：表示可以有一个类型，也可以是 undefined。

只读类型 (Readonly Types)：表示只读属性或只读数组。

### ts 高级类型使用过哪些？

交叉类型（Intersection Types）：表示将多个类型合并为一个新类型。
```typescript
type A = { a: number };
type B = { b: string };
type C = A & B; // { a: number, b: string }
```

联合类型（Union Types）：表示一个值可以是多种类型之一。
```typescript
type MyType = string | number;
```

类型别名（Type Aliases）：给一个类型起一个新名字，可以更方便地引用复杂类型。
```typescript
type Age = number;
type Person = {
  name: string;
  age: Age;
};
```
字面量类型（Literal Types）：表示一个具体的值。
```typescript
type Direction = 'left' | 'right' | 'up' | 'down';
```

映射类型（Mapped Types）：用于从一个旧类型生成一个新类型。
```typescript
type Readonly<T> = {
  readonly [P in keyof T]: T[P];
};
```
索引类型（Index Types）：用于获取对象中属性的类型。
```typescript
type Person = {
  name: string;
  age: number;
};
type AgeType = Person['age']; // number
```

条件类型（Conditional Types）：根据类型关系选择不同的类型。
```typescript
type NonNullable<T> = T extends null | undefined ? never : T;
```

显式赋值断言（Definite Assignment Assertion）：在变量声明时告诉编译器该变量一定会被赋值。
```typescript
let x!: number;
```

可选链操作符（Optional Chaining Operator）：用于访问可能不存在的属性或方法，防止出现错误。
```typescript
const name = obj?.person?.name;
```

空值合并运算符（Nullish Coalescing Operator）：用于提供默认值，当值为 null 或 undefined 时生效。
```typescript
const result = input ?? defaultValue;
```

### ReturnType 怎么实现？
需要使用`extends`和`infer`关键字
```ts
type MyReturnType<T extends (...args: any[]) => any> = T extends (...args: any[]) => infer R ? R : any;
```
### 说一下 extends infer？
`extends` 关键字用于检查一个类型是否满足某种条件。
```ts 
T extends U ? X : Y
```
`infer` 关键字用于推断待定的类型。它的作用是从给定的类型中提取类型，并将提取的类型赋值给一个类型变量。infer 关键字通常与泛型结合使用，以提取类型并赋值给泛型参数。
```ts
type MyType<T> = T extends SomeType<infer U> ? U : DefaultType;
```

# webpack

### 讲一下webpack常用的属性 如何实现不将react和antd不打包
entry
output
loader
plugin

疑问点：
如何实现不将react和antd不打包
`externals`属性

``` js
module.exports = {
  // ...
  externals: {
    'react': 'React',
    'react-dom': 'ReactDOM',
    'antd': 'antd'
  }
}
```

# 浏览器

### 说一下浏览器的同源策略
同源策略是浏览器的一项安全策略
目的：用于保护用户数据的安全性
据同源策略，浏览器限制了不同源的网页之间的交互行为，以防止恶意网站获取用户的敏感信息

### 有哪些方式可以实现跨域？
JSONP（JSON with Padding）：JSONP 是一种通过动态创建 <script> 标签来实现跨域请求的方法。服务器返回的数据会被包裹在一个函数调用中，前端通过定义一个同名的函数来接收返回的数据。

CORS（跨域资源共享）：CORS 是一种基于 HTTP 头部的机制，允许浏览器向服务器发出跨域请求。通过在服务器端设置响应头中的 CORS 头部字段，指定哪些源可以访问该资源。

代理：通过在同源的服务器上设置代理，将跨域请求转发到目标服务器上。前端将请求发送给同源的服务器，再由服务器转发给目标服务器，并将目标服务器的响应返回给前端。

WebSocket：WebSocket 是一种双向通信协议，它允许浏览器与服务器之间建立持久的连接。由于 WebSocket 采用了自定义的协议，不受同源策略的限制，因此可以实现跨域通信。

跨文档通信 API：HTML5 提供了一些跨文档通信的 API，如 postMessage 方法，可以在不同窗口或跨域的 iframe 之间传递消息。

反向代理：通过在服务器上设置反向代理，将外部请求转发到目标服务器上，并将响应返回给请求方。这样前端只需要与同源的服务器进行通信，而不需要直接与目标服务器进行跨域请求。

# 个人项目


